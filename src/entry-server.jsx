import React from 'react';
import { renderToString } from 'react-dom/server';
import {
  createStaticHandler,
  createStaticRouter,
  StaticRouterProvider,
} from 'react-router';
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import createEmotionServer from '@emotion/server/create-instance';
import createCache from '@emotion/cache';
import { CacheProvider } from '@emotion/react';

import { publicRoutes, LandingPage } from './routes';
import { theme } from './theme';
import RootLayout from './components/RootLayout';

// AuthContext is swapped to the server stub via Vite resolve alias during SSR build,
// so any component importing useAuth() will get no-op defaults.

// ----- Route definitions for SSR -----
// Only public routes are included. The root "/" renders LandingPage directly
// (on the server there is no auth state, so no redirect logic is needed).
const ssrRoutes = [
  {
    path: '/',
    element: <RootLayout />,
    children: [
      {
        path: '/',
        element: <LandingPage />,
      },
      ...publicRoutes,
    ],
  },
];

/**
 * Render a given URL to an HTML string + extracted critical CSS.
 * Called by the SSR Cloud Function for each incoming request.
 *
 * @param {string} url - The request URL path (e.g. "/features")
 * @returns {Promise<{ html: string, css: string, redirect?: string, status?: number }>}
 */
export async function render(url) {
  // 1. Create a fresh Emotion cache for this request
  const emotionCache = createCache({ key: 'css' });
  const { extractCriticalToChunks, constructStyleTagsFromChunks } =
    createEmotionServer(emotionCache);

  // 2. Use React Router static APIs to resolve the route
  const handler = createStaticHandler(ssrRoutes);

  // createStaticHandler.query expects a Fetch API Request object
  const fetchRequest = new Request(`http://localhost${url}`, {
    method: 'GET',
    headers: { Accept: 'text/html' },
  });

  const context = await handler.query(fetchRequest);

  // If the context is a Response (e.g. redirect), signal to the caller
  if (context instanceof Response) {
    return {
      html: '',
      css: '',
      redirect: context.headers.get('Location'),
      status: context.status,
    };
  }

  const router = createStaticRouter(handler.dataRoutes, context);

  // 3. Render the component tree to an HTML string
  const appHtml = renderToString(
    <CacheProvider value={emotionCache}>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <StaticRouterProvider router={router} context={context} />
      </ThemeProvider>
    </CacheProvider>
  );

  // 4. Extract critical CSS that was generated by Emotion / MUI
  const emotionChunks = extractCriticalToChunks(appHtml);
  const emotionCss = constructStyleTagsFromChunks(emotionChunks);

  return { html: appHtml, css: emotionCss };
}
